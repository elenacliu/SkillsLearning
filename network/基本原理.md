考得比较多的是：网络层，传输层，应用层

# 传输层

传输层协议是在端系统而不是在路由器中实现的，只工作在端系统中。

在发送端，传输层将发送应用程序进程接收到的报文转换成**传输层分组**。**在发送端系统中**，传输层将这些报文段传递给网络层，网络层将其封装成网络层分组（即数据报）并向目的地发送。

一个重要事实：网络路由器仅作用于该数据报的网络层字段。不检查封装在该数据报中的传输层报文段的字段。

## 传输层和网络层的关系

网络层提供了*主机*之间的逻辑通信，而传输层为运行在不同主机上的进程之间提供了逻辑通信。

在端系统中，传输层协议将来自应用进程的报文**移动到网络边缘**（即网络层）（Q: 这里的网络边缘指的是主机上的哪个部分？）

传输协议能够提供的服务常常受制于底层网络层协议的服务模型。如果网络层协议无法为主机之间发送的传输层报文段提供时延或者带宽保证，传输层协议也就无法为进程之间发送的应用程序报文提供时延或者带宽保证。

但即使底层网络协议是不可靠的，运输协议也能为应用程序提供可靠的数据传输服务。

我们将 TCP 和 UDP 的分组统称为报文段(segment)，而数据报(datagram)指的是网络层分组。

## 传输层概述

UDP 仅能提供进程到进程的数据交付和差错检查

TCP 除此之外还提供了几种附加服务。

1. 可靠数据传输：通过**流量控制、序号seq、确认ack、和定时器**，TCP 确保正确地、按序地将数据从发送进程交付给接收进程
2. 拥塞控制：力求为每一个通过一条拥塞网络连续地连接平等地共享网络链路带宽。可以通过调节 TCP 连接的发送端发送进网络的流量速率来做到。

## 多路复用与多路分解

目的主机的传输层从更底层的网络层接收数据时，需要将所接收到的数据定向到这4个进程中的一个。

一个进程有一个或多个 socket，它相当于从网络到进程传递数据和从进程到网络传递数据的通道。因此，接收主机上的传输层实际上并没有直接将数据交付给进程，而是将数据交给了一个中间的套接字。套接字具有唯一的标识符。

<img src="https://i.loli.net/2021/05/12/M1SWuUl5bXVNfCk.png" alt="image.png" style="zoom:50%;" />

多路分解：目的主机怎么把传输层报文段定向到合适的套接字呢？每个传输层报文段中具有几个字段。在接收端，传输层检查这些字段，并标识出套接字，进而将报文段定向到该套接字。

多路复用：源主机从不同的套接字中收集数据块，并未每个数据块封装上首部信息（以便于之后分解）从而生成报文段，然后将报文段传递到网络层。

端口号是16bit的数，大小在0~65535之间。

0~1023：周知端口号

### 无连接的多路复用与多路分解

UDP socket: 二元组全面标识，该二元组包含一个目的 IP 地址和一个目的端口号

应用程序的客户端让运输层自动且透明地分配端口号，而服务器端则分配一个特定的端口号

### 面向连接的多路复用与多路分解

TCP socket: 四元组，(源 IP，源端口号，目的 IP，目的端口号) 所以这四个值唯一确定了一个连接

特别与 UDP 不同的是，两个具有不同**源 IP 地址或源端口号**的到达 TCP 报文段将被定向到两个不同的套接字（由此可见，同一个服务进程可以拥有多个套接字），除非 TCP 报文段携带了初始创建连接的请求。

服务器主机可以支持很多并行的 TCP 套接字，每个套接字都与一个进程相关联。当一个 TCP 报文段到达主机时，所有 4 个字段被用来将报文段定向分解到响应的套接字。

如今的高性能服务器只用一个进程，但为每个新的客户连接创建一个具有新连接套接字的新线程。（线程可以看作一个轻量级的子进程）。对这种服务器，在任意给定的时间内都有可能有具有不同标识的许多连接套接字连接到相同进程。



# TCP 和 UDP 协议的区别？

首先分别看看他们俩是什么。

TCP: **传输控制**协议 (transmission control protocol) 面向连接服务和可靠数据传输服务；拥塞控制

+ **面向连接**：在应用层数据报文开始流动之前，TCP 让客户和服务器相互交换**传输层控制信息。**这个所谓的握手过程提醒客户端和服务器，让它们为大量分组的到来做好准备。在握手阶段后，**一个 TCP 连接就在两个进程的套接字之间建立**了。这条连接是**全双工**的，即连接双方的进程可以在此连接上同时进行报文收发。当应用程序结束报文发送时，必须拆除连接。注意：也有无连接的套接字……

  + what is socket? a **socket** is one endpoint of a **two way** communication link between two programs running on the network. socket=（ip, port）

  + 一个听说过的名词：WebSocket 是完整的应用层协议。是在单个 TCP 连接上进行**全双工**（发送的同时也能接受）通信的协议。WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成**一次握手**，两者之间就可以创建持久性的连接，并进行双向数据传输。

    <img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017051502.png" alt="websocket" style="zoom: 67%;" />

  + 建立连接（三次握手），释放连接（三次握手+定时器）

+ **可靠的**：当应用程序的一端将字节流传进套接字时，它能够依靠 TCP 将相同的字节流交付给接收方的套接字，而没有字节的丢失和冗余。

  滑动窗口协议：利用超时重传、发送和接受端到端的确认分组等机制。（IP层是不可靠的）

+ **端到端的**：socket

+ **基于字节流的**：基于字节流而非消息流

  + 什么是字节流，什么是消息流？

协议解决的主要问题：

连接管理：建立**连接**（三次握手），释放**连接**（三次握手+定时器）

**可靠传输**：滑动窗口（保证顺序）

流控制和**拥塞控制**：可变滑动窗口，慢启动，拥塞避免

>  无论 TCP 还是 UDP 都没有提供任何加密机制。
>
> TCP 的加强版：安全套接字层 SSL(secure socket layer) 用 SSL 加强后的 TCP 不仅能够做传统 TCP 能做的一切，而且提供了关键的进程到进程的安全性服务，包括**加密、数据完整性**和**端点鉴别**。SSL 不是于 TCP 和 UDP 在相同层次上的第三种传输协议，而是一种对 TCP 的加强，这种强化是在应用层上实现的。
>
> 如果一个应用程序要使用 SSL 的服务，它需要在该应用程序的客户端和服务器端包括 SSL 代码（利用现有的高度优化的库和类）。SSL 有自己的套接字 API，这类似于传统的 TCP 套接字 API。
>
> `发送进程（明文）->SSL套接字（密文）->发送进程的TCP套接字（密文）->网络（密文）->接收进程的 TCP 套接字（密文）-> SSL 套接字（密文）-> 接收进程（明文）`







## UDP: 用户数据协议(User Data Protocol)

不提供不必要服务的轻量级传输协议，仅提供最小服务。

无连接（两个进程通信前没有握手过程）

不可靠数据传输（UDP协议不保证报文将到达接收进程，且报文到达的顺序可能是乱序的）

无拥塞控制机制（所以 UDP 的发送端可以用它选定的任何速率向其下层（网络层）注入数据）

用于谷歌的 Chrome 浏览器中的 QUIC 协议(一个传输层网络协议)(快速 UDP 因特网连接) 将 UDP 作为其支撑运输协议并在 UDP 之上的应用层协议中实现可靠性.

**HTTP/3** 是即将到来的第三个主要版本的[HTTP](https://zh.wikipedia.org/wiki/HTTP)协议，使用于[万维网](https://zh.wikipedia.org/wiki/万维网)。与其前任[HTTP/1.1](https://zh.wikipedia.org/wiki/超文本传输协议#HTTP/1.1)和[HTTP/2](https://zh.wikipedia.org/wiki/HTTP/2)不同，在HTTP/3中，将弃用[TCP](https://zh.wikipedia.org/wiki/传输控制协议)协议，改为使用基于[UDP](https://zh.wikipedia.org/wiki/用户数据报协议)协议的[QUIC](https://zh.wikipedia.org/wiki/快速UDP网络连接)协议实现。截至2021年5月，HTTP/3仍然是草案状态。

UDP 的特点;

+ 关于发送什么数据以及何时发送的控制更精细
+ 无须建立连接
+ 无连接状态：TCP 在端系统中要维护连接状态。此连接状态包括接收和发送缓存、拥塞控制参数以及序号和确认号的参数
+ 分组首部开销小。TCP: 20 字节 UDP: 8 字节

使用 UDP 的应用是可能实现可靠数据传输的。这可以通过在应用程序自身中建立可靠性机制来完成（其实就是自己造轮子……）

<img src="https://i.loli.net/2021/05/12/QyER42szPiOLNIx.png" alt="image.png" style="zoom:67%;" />

UDP 报文结构：

![image.png](https://i.loli.net/2021/05/12/kOVISFZ3rJnpzcH.png)

长度字段：首部长度 + 数据长度

UDP计算校验和的方法和IP数据报首部校验和的方法相似。不同的是：IP数据报校验和**只校验IP数据报的首部**，但UDP的校验和是把**首部和数据部分**一起都检验。

```html
  				  0      7 8     15 16    23 24    31
                 +--------+--------+--------+--------+
                 |     Source      |   Destination   |
                 |      Port       |      Port       |
                 +--------+--------+--------+--------+
                 |                 |                 |
                 |     Length      |    Checksum     |
                 +--------+--------+--------+--------+
                 |
                 |          data octets ...
                 +---------------- ...
```

伪首部(pseudo header): conceptually prefixed to the UDP header contains the source address, the destination address, the protocol, the UDP length. 

```html
 				  0      7 8     15 16    23 24    31 
                 +--------+--------+--------+--------+
                 |          source address           |
                 +--------+--------+--------+--------+
                 |        destination address        |
                 +--------+--------+--------+--------+
                 |  zero  |protocol|   UDP length    |
                 +--------+--------+--------+--------+
```

**伪首部**的作用：并非 UDP 报文的实际部分。是一个虚拟的数据结构，其中的信息是从报文所在 IP 分组头中提取的，仅仅只是为了计算校验和。（Q：发送方的 UDP 还没发出去的时候，怎么知道 IP 分组头是啥呢？？到传输层来的时候，IP 分组头应该也被去掉了呀）



## 可靠数据传输协议

基于 ACK 和 NAK 重传机制的可靠数据传输协议称为自动重传请求(ARQ 协议)

NAK: 否定确认

ACK: 肯定确认

如果采取 rdt2.0 版本，根本问题在于没有考虑到 ACK 或者 NAK 分组受损的可能性。如果发送方收到含糊不清的 ACK 或者 NAK 分组，就重传当前数据分组的话，相当于在发送方到接收方的信道中引入了冗余分组。冗余分组的根本困难在于接收方不知道它上次所发送的 ACK 或者 NAK 是否被发送方正确地收到。因此**它无法事先知道接收到地分组是新的还是一次重传**。

为了鉴别新分组和重传分组，解决的方法是：在数据分组中添加一个新字段，让**发送方**对其数据分组编号，即将发送数据分组的**序号**放在该字段。于是，接收方只需要检查序号，即可确定收到的分组是否是一次重传。

## 回退 N 步

2021.05.12

暂时略

## 选择重传

2021.05.12

暂时略



# 应用层概述

TCP/IP 中的应用层包括了 OSI 模型中会话层、表示层、应用层的功能。

**会话层**：建立或者解除与别的接点的联系（确定连接的时机）

**表示层**：数据格式化，数据加密等（应用进程对发送的数据进行封装）

**应用层**：提供用户使用的功能

其中会话层和表示层没有对应的协议



CS architecture: Web, FTP, Telnet 和电子邮件（这些是具体的应用）

P2P: 对专用服务器有最小的或者没有依赖。应用程序在间断连接的主机对之间使用直接通信，这些主机被称为对等方。

1. 客户和服务器进程的定义：在一对进程之间的通信会话场景中，发起通信（即在该会话开始时**发起与其他进程的联系**）的进程被标识为客户进程，在会话开始时等待联系的进程是服务器进程。

2. 进程与计算机网络之间的接口：

   进程通过一个socket的软件接口向网络发送报文和从网络接收报文。进程是房子，socket是门。socket 是同一台主机内应用层和传输层之间的接口。应用程序开发者可以控制套接字在应用层端的一切，但是对该套接字的运输层端几乎无控制权。

3. 进程寻址：在一台主机上运行的进程为了向在另一台主机上运行的进程发送分组，接收进程需要有一个地址。为了标识接收进程，需要定义：主机的地址(IP address)；在目的主机中指定接收进程的标识符(接收套接字)。因此 socket由 (ip, port) 来标识

# 应用层协议

把报文发送进他套接字实现网络进程间的相互通信。但：如何构造报文？报文中各个字段的含义是什么？进程何时发送这些报文？由应用层协议定义。应用层协议有公共的和专用的。

## HTTP 和 HTTPS

### 概况

HyperText Transfer Protocol

HTTP 本身由两个程序实现：一个客户程序和一个服务器程序

HTTP 报文

服务器向客户发送被请求的文件，而不存储任何关于该客户的状态信息。HTTP 是无状态协议。

### 非持续连接和持续连接

每个请求/响应对是经一个单独的TCP连接发送，还是所有的请求及其响应经相同的TCP连接发
送呢？

采用前一种方法，该应用程序被称为使用非持续连接(non-persistent connection)；
采用后一种方法，该应用程序被称为使用持续连接(persistent connection) 

1. 采用非持续连接的 HTTP

   串行的 TCP 连接和并行的 TCP 连接，用户能够配置浏览器的 TCP 连接并行度，每条连接处理一个请求响应事务。使用并行连接可以缩短响应时间。

   RTT: Round-Trip Time，往返时间。一个短分组从客户端到服务器然后再返回客户端所花费的时间。

   粗略地讲，对于非持续连接，总响应时间是 2\*RTT+服务器传输 HTML 文件的时间（客户可以结合三次握手中的第三部分（确认）向该 TCP 连接发送一个 HTTP 请求报文）

2. 采用持续连接的 HTTP

   如果一条连接经过一定时间间隔（可配置的超时间隔）仍未被使用，HTTP 服务器就关闭该连接。HTTP 的默认模式是**带流水线的持续连接**

### 报文格式

1. 请求报文：ASCII 文本；至少为1行

   HTTP 请求报文的第一行：

   **请求行**，三个字段，方法字段(GET, POST, HEAD, PUT, DELETE)，URL 字段和 HTTP 版本字段

   **首部行**：

   + Host: 主机，Web 代理高速缓存所要求的 
   + Connection: close，表面服务器不要用持续连接(keep-alive)，而是在发送完请求就关闭这条 TCP 连接
   + User-agent: 用户代理，即向服务器发送请求的浏览器的类型
   + Accept-language: 首部行表示用户向得到该对象的语言版本

   **entity-body**: 当 POST 请求时，实体体中是表单内容

   ![image.png](https://i.loli.net/2021/05/10/U29nhv5rNtJYd1p.png)

2. 响应报文

   初始状态行：协议版本，状态码，相应状态信息

   首部行：

   + Last-Modified: 对既可能在本地客户端也可能在网络缓存服务器上的对象缓存来说非常重要
   + Content-Type: 实体体中的对象的类型

   实体体：包含了所请求的对象本身

   ![image.png](https://i.loli.net/2021/05/10/lHVvw4QUdzcEJMT.png)

### 用户与服务器的交互：cookie

用来做用户跟踪

cookie 技术的四个组件：1. 在 HTTP 响应报文中的一个 cookie 首部行  2. 在 HTTP 请求报文中的一个 cookie 首部行 3. 在用户端系统中保留有一个 cookie 文件，并由用户的浏览器进行管理 4. 位于 web 站点的一个后端数据库

cookie 的工作方式：客户访问服务器时，服务器产生一个唯一标识并以此为索引在数据库中产生对应表项，并在响应请求的Set-cookie: 首部项中附带这个唯一标识；浏览器在它管理的特定的 cookie 文件中添加一行，该行包含服务器的主机名和 Set-cookie: 首部项中的识别码。之后当客户继续访问该网站时，每请求一个 Web 页面，浏览器就会查询该 cookie 文件并抽取客户对这个网站的识别码，并放到 HTTP 请求报文中包括识别码的 Cookie: 首部行中。

### Web 缓存

web 缓存器也叫代理服务器，它是能够代表初始Web服务器来满足HTTP请求的网络实体。

使用 Web 缓存技术有两个原因

+ 大大减少请求的响应时间；尤其是当客户与初始服务器之间的瓶颈带宽远低于客户与 Web 缓存器之间的瓶颈带宽时。相比增加带宽，这种方式成本很低。
+ 从整体上大大减低 Internet 上的 Web 流量

条件 GET 方法：缓存器证实自己的对象是最新的

缓存器向服务器发送一个条件 GET 执行最新检查。请求报文中带有 If-modified-since 首部行，该值正好等于上一次服务器发送的响应报文中的 Last-Modified: 首部行的值。该报文告诉服务器，仅当自指定日期之后该对象被修改过，才发送该对象。接下来，Web 服务器向缓存器发送一个响应报文，如果对象没有被修改过，entity body 为空。

### HTTP 1.1/2/3 区别

### HTTPS 和 HTTP 区别

HTTPS (Hyper Text Transfer Protocol Secure) appears in the URL when a website is secured by an SSL certificate.

TLS (Transport Layer Security) is just an updated, more secure, version of SSL.

## DNS：因特网的目录服务

主机的标识方式：1. 主机名 2. ip 地址

IPv4: 4 字节，且有严格层次结构。

域名系统：Domain Name System, DNS, 进行主机名到 IP 地址的转换。

DNS 的定义：

+ 一个由**分层的 DNS 服务器**实现的分布式数据库
+ 一个使得主机能够**查询分布式数据库**的**应用层协议**

运行在 UDP 之上，端口53。

浏览器抽取主机名，并将主机名传给 DNS 的客户端 -> DNS 客户向 DNS 服务器发送包含主机名的请求 -> DNS 客户最终收到一份回答报文，其中含有对应于该主机名的 IP 地址 -> 浏览器收到 IP 地址，向该 IP 地址 80 端口的 HTTP 服务器进程发起 TCP 连接

> 一个端口号是否可以被多个进程绑定？
>
> 同种协议通常不可以。不同协议（TCP 和 UDP）可以。
>
> 但如果进程先绑定一个端口号，然后 fork 一个子进程，这样可以实现多个进程绑定一个端口号。

DNS 的其他服务：主机别名、邮件服务器别名、负载分配

### DNS 工作机理

1. 分布式、层次数据库

   根DNS服务器（提供 TLD 顶级域名服务器的 IP 地址）

   顶级域名服务器：提供了权威 DNS 服务器的 IP 地址

   权威 DNS 服务器

   <img src="https://i.loli.net/2021/05/11/TNYQEahPHneU8lF.png" alt="image.png" style="zoom:80%;" />

上面的例子假设 TLD 服务器知道用于主机的权威 DNS 服务器的 IP 地址。但其实 TLD 服务器知识知道中间的某个 DNS 服务器，该中间服务器依次迭代才能知道用于该主机的权威 DNS 服务器。

### 递归查询和迭代查询

从 cse.nyu.edu 到 dns.nyu.edu 发出的查询是递归查询，因为该查询以自己的名义请求 dns.nyu.edu 来获得该映射。而后继的3个查询是迭代查询，因为所有的回答都是直接返回给 dns.nyu.edu。

实践中，查询通常是图2-18中的模式，从请求主机到本地 DNS 服务器的查询时递归的，其余的查询都是迭代的。

### DNS 缓存

本地 DNS 服务器能够缓存一个 DNS 回答。“权威应答（权威服务器给出的）和非权威应答（DNS 缓存给出的）”

本地 DNS 服务器也能够缓存 TLD 服务器的 IP 地址，因而允许本地 DNS 绕过查询链中的根 DNS 服务器。（一般都不会向根服务器请求）

### DNS 记录和报文

共同实现 DNS 分布式数据库的所有 DNS 服务器存储了资源记录（Resource Record）。RR 提供了主机名到 IP 地址的映射。每个 DNS 回答报文包含了一条或多条资源记录。

资源记录是4元组：

(Name, Value, Type, TTL)

+ Type = A, Name = 主机名，Value 是该主机名对应的 IP 地址

+ Type = NS, Name 是域名，Value 是知道如何获得该域中主机 IP 地址的权威 DNS 服务器的**主机名（不是 IP 地址！）** (foo.com, dns.foo.coom, NS) **问题：那么怎么找到权威主机名的 IP 呢**？

  ![image.png](https://i.loli.net/2021/05/11/lBbEOgJoS5kUMrH.png)

+ Type = CNAME, Value 是别名为 Name 的主机的规范主机名

+ Type = MX, Value 是别名为 Name 的邮件服务器的规范主机名。

DNS 报文：查询和回答报文格式相同

### DNS 缓存污染

刻意制造或无意中制造出来的域名服务器数据包，把域名指向不正确的 IP 地址。

## WebSocket

WebSocket是一种与[HTTP](https://zh.wikipedia.org/wiki/超文本传输协议)不同的协议。

建立在TCP协议上，服务端实现容易。

与 HTTP 协议有着良好的兼容性。默认端口也是**80和443**（说了默认那肯定是可以修改的），并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。

![](http://www.ruanyifeng.com/blogimg/asset/2017/bg2017051503.jpg)

可以发送文本，也可以发送二进制数据。

没有**同源**（协议相同，域名相同，端口相同）限制，客户端可以与任意服务器通信。（因为有 origin 字段）



# 网络层



# QA

1. TCP 分组？

2. SSL 非对称加密算法？

3. HTTP 1.1 2 3 区别

   怎么理解TCP是面向连接的，HTTP基于TCP却是无连接的？ - 二大王的回答 - 知乎 https://www.zhihu.com/question/51996213/answer/128801185

4. HTTPS 有 2 还是 3 之说吗？

5. 互联网 以太网 World Wide Web

6. session 机制如何工作

7. OSI 七层模型 / tcp/ip 四层模型 每一层的工作：物理层，网络层，传输层，应用层好说……但数据链路层？？

8. 从 URL 在浏览器被被输入到页面展现的过程中发生了什么？
9. 连接的本质？不是物理上的那种连接。感觉像是双方通过互换信息（”握手“），进行彼此身份的确认，同时保证能够成功传输。